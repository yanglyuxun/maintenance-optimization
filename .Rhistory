}
text(df$longitude[selection]+0.5,df$latitude[selection]+0.1,labels = N.monitor,col=1)
plot(df$longitude,df$latitude,col=classn+1)
text(df$longitude,df$latitude,labels = df$dist,col=classn+1)
points(df$longitude[selection],df$latitude[selection],pch=19,col=1)
class.selection = selection[classn]
#计算每个驻扎点需要监控的电站数目
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = sum(df$install[classn==i])
}
text(df$longitude[selection]+0.3,df$latitude[selection]+0.1,labels = N.monitor,col=1)
N.people = N.monitor/4
N.people = round(N.monitor/4)
N.people = round(N.monitor/4/250)
N.monitor/4/250
N.people = round(N.monitor/4/250+0.5)
(N.people = round(N.monitor/4/250+0.5))
N.people = round(N.monitor/4/250+0.5)
names(N.people) = result$cities
N.people
# 每人每天看4个，每年工作250天，每年所有电站看1次
N.people = round(N.monitor/4/250+0.5)
names(N.people) = result$cities
N.people
# 每人每天看4个，每年工作250天，每年所有电站看2次
N.people = round(N.monitor*2/4/250+0.5)
names(N.people) = result$cities
N.people
plot(df$longitude,df$latitude,col=classn+1)
text(df$longitude,df$latitude,labels = df$dist,col=classn+1)
points(df$longitude[selection],df$latitude[selection],pch=19,col=1)
class.selection = selection[classn]
#计算每个驻扎点需要监控的电站数目
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = sum(df$install[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.monitor,col=1)
text(df$longitude[selection]+0.2,df$latitude[selection]-0.2,labels = N.people,col=1)
selection = result$selection #驻扎点
classn = apply(cost[selection,],2,which.min) #每个城市分类
plot(df$longitude,df$latitude,col=classn+1)
text(df$longitude,df$latitude,labels = df$dist,col=classn+1)
points(df$longitude[selection],df$latitude[selection],pch=19,col=1)
class.selection = selection[classn]
#计算每个驻扎点需要监控的电站数目
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = sum(df$install[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.monitor,col=1)
#人手数目
# 每人每天看4个，每年工作250天，每年所有电站看1次
N.people = round(N.monitor/4/250+0.5)
names(N.people) = result$cities
N.people
text(df$longitude[selection]+0.2,df$latitude[selection]-0.2,labels = N.people,col=1)
# 每人每天看4个，每年工作250天，每年所有电站看2次
N.people = round(N.monitor*2/4/250+0.5)
names(N.people) = result$cities
N.people
plot(df$longitude,df$latitude,col=classn+1)
text(df$longitude,df$latitude,labels = df$dist,col=classn+1)
points(df$longitude[selection],df$latitude[selection],pch=19,col=1)
class.selection = selection[classn]
#计算每个驻扎点需要监控的电站数目
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = sum(df$install[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.monitor,col=1)
#计算每个驻扎点需要修理的电站数目
N.repair = rep(0,5)
for(i in 1:5){
N.repair[i] = sum(df$abnormal[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.repair,col=1)
#人手数目
# 每人每天看4个，每年工作250天，每年所有电站看1次
N.people = round(N.monitor/4/250+0.5)
names(N.people) = result$cities
N.people
text(df$longitude[selection]-0.2,df$latitude[selection],labels = N.people,col=1)
# 每人每天看4个，每年工作250天，每年所有电站看2次
N.people = round(N.monitor*2/4/250+0.5)
names(N.people) = result$cities
N.people
plot(df$longitude,df$latitude,col=classn+1)
text(df$longitude,df$latitude,labels = df$dist,col=classn+1)
points(df$longitude[selection],df$latitude[selection],pch=19,col=1)
class.selection = selection[classn]
#计算每个驻扎点需要监控的电站数目
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = sum(df$install[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.monitor,col=1)
#计算每个驻扎点需要修理的电站数目
N.repair = rep(0,5)
for(i in 1:5){
N.repair[i] = sum(df$abnormal[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]-0.1,labels = N.repair,col=1)
#人手数目
# 每人每天看4个，每年工作250天，每年所有电站看1次
N.people = round(N.monitor/4/250+0.5)
names(N.people) = result$cities
N.people
text(df$longitude[selection]-0.2,df$latitude[selection],labels = N.people,col=1)
# 每人每天看4个，每年工作250天，每年所有电站看2次
N.people = round(N.monitor*2/4/250+0.5)
names(N.people) = result$cities
N.people
plot(df$longitude,df$latitude,col=classn+1)
text(df$longitude,df$latitude,labels = df$dist,col=classn+1)
points(df$longitude[selection],df$latitude[selection],pch=19,col=1)
class.selection = selection[classn]
#计算每个驻扎点需要监控的电站数目
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = sum(df$install[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.monitor,col=1)
#计算每个驻扎点需要修理的电站数目
N.repair = rep(0,5)
for(i in 1:5){
N.repair[i] = sum(df$abnormal[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]-0.1,labels = N.repair,col=1)
#人手数目
# 每人每天看4个电站，每3天修1个电站，每年工作250天，每年所有电站看1次
N.people = max(round(N.monitor/4/250+0.5),round(N.repair*3/250+0.5))
names(N.people) = result$cities
N.people
text(df$longitude[selection]-0.2,df$latitude[selection],labels = N.people,col=1)
# 每人每天看4个，每3天修1个电站，每年工作250天，每年所有电站看2次
N.people2 = max(round(N.monitor/4/250+0.5),round(N.repair*3/250+0.5))
names(N.people2) = result$cities
N.people2
compare = function(x,y){
mat = cbind(x,y)
apply(mat,1,max)
}
N.people = compare(round(N.monitor/4/250+0.5),round(N.repair*3/250+0.5))
compare = function(x,y){ #用来找到两个vector中较大的
mat = cbind(x,y)
apply(mat,1,max)
}
N.people = compare(round(N.monitor/4/250+0.5),round(N.repair*3/250+0.5))
plot(df$longitude,df$latitude,col=classn+1)
text(df$longitude,df$latitude,labels = df$dist,col=classn+1)
points(df$longitude[selection],df$latitude[selection],pch=19,col=1)
class.selection = selection[classn]
#计算每个驻扎点需要监控的电站数目
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = sum(df$install[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.monitor,col=1)
#计算每个驻扎点需要修理的电站数目
N.repair = rep(0,5)
for(i in 1:5){
N.repair[i] = sum(df$abnormal[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]-0.1,labels = N.repair,col=1)
#人手数目
# 每人每天看4个电站，每3天修1个电站，每年工作250天，每年所有电站看1次
compare = function(x,y){ #用来找到两个vector中较大的
mat = cbind(x,y)
apply(mat,1,max)
}
N.people = compare(round(N.monitor/4/250+0.5),round(N.repair*3/250+0.5))
names(N.people) = result$cities
N.people
text(df$longitude[selection]-0.2,df$latitude[selection],labels = N.people,col=1)
# 每人每天看4个，每3天修1个电站，每年工作250天，每年所有电站看2次
N.people2 = compair(round(N.monitor/4/250+0.5),round(N.repair*3/250+0.5))
names(N.people2) = result$cities
N.people2
compare = function(x,y){mat = cbind(x,y);apply(mat,1,max)} #用来找到两个vector中较大的
N.people = compare(round(N.monitor/4/250+0.5),round(N.repair*3/250+0.5))
names(N.people) = result$cities
N.people
text(df$longitude[selection]-0.2,df$latitude[selection],labels = N.people,col=1)
N.people2 = compair(round(N.monitor/4/250+0.5),round(N.repair*3/250+0.5))
names(N.people2) = result$cities
N.people2
N.people2 = compare(round(N.monitor/4/250+0.5),round(N.repair*3/250+0.5))
names(N.people2) = result$cities
N.people2
N.people2 = compare(round(N.monitor*2/4/250+0.5),round(N.repair*2*3/250+0.5))
names(N.people2) = result$cities
N.people2
greedy(5)
enumerate(5)
selection = result$selection #驻扎点
classn = apply(cost[selection,],2,which.min) #每个城市分类
plot(df$longitude,df$latitude,col=classn+1)
text(df$longitude,df$latitude,labels = df$dist,col=classn+1)
points(df$longitude[selection],df$latitude[selection],pch=19,col=1)
class.selection = selection[classn]
#计算每个驻扎点需要监控的电站数目
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = sum(df$install[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.monitor,col=1)
#计算每个驻扎点需要修理的电站数目
N.repair = rep(0,5)
for(i in 1:5){
N.repair[i] = sum(df$abnormal[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]-0.1,labels = N.repair,col=1)
#人手数目
# 每人每天看4个电站，每3天修1个电站，每年工作250天，每年所有电站看1次
compare = function(x,y){mat = cbind(x,y);apply(mat,1,max)} #用来找到两个vector中较大的
N.people = compare(round(N.monitor/4/250+0.5),round(N.repair*3/250+0.5))
names(N.people) = result$cities
N.people
text(df$longitude[selection]-0.2,df$latitude[selection],labels = N.people,col=1)
# 每人每天看4个，每3天修1个电站，每年工作250天，每年所有电站看2次
N.people2 = compare(round(N.monitor*2/4/250+0.5),round(N.repair*2*3/250+0.5))
names(N.people2) = result$cities
N.people2
result
result
selection = result$selection #驻扎点
classn = apply(cost[selection,],2,which.min) #每个城市分类
plot(df$longitude,df$latitude,col=classn+1)
text(df$longitude,df$latitude,labels = df$dist,col=classn+1)
points(df$longitude[selection],df$latitude[selection],pch=19,col=1)
class.selection = selection[classn]
#计算每个驻扎点需要监控的电站数目
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = sum(df$install[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.monitor,col=1)
#计算每个驻扎点需要修理的电站数目
N.repair = rep(0,5)
for(i in 1:5){
N.repair[i] = sum(df$abnormal[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]-0.1,labels = N.repair,col=1)
#人手数目
# 每人每天看4个电站，每3天修1个电站，每年工作250天，每年所有电站看1次
compare = function(x,y){mat = cbind(x,y);apply(mat,1,max)} #用来找到两个vector中较大的
N.people = compare(round(N.monitor/4/250+0.5),round(N.repair*3/250+0.5))
names(N.people) = result$cities
N.people
text(df$longitude[selection]-0.2,df$latitude[selection],labels = N.people,col=1)
# 每人每天看4个，每3天修1个电站，每年工作250天，每年所有电站看2次
N.people2 = compare(round(N.monitor*2/4/250+0.5),round(N.repair*2*3/250+0.5))
names(N.people2) = result$cities
N.people2
# 数据输入
df = read.csv("租赁业务监控安装与并网情况表5.9.csv",encoding = 'UTF-8',stringsAsFactors = F)
df = df[1:42,1:3]
names(df)=c("dist","install","abnormal")
df$ab.rate = df$abnormal / df$install    # abnormal rate
# 合并重复区域
dist.new = unique(df$dist)
abnormal.new = sapply(dist.new,function(x) sum(df$abnormal[df$dist==x]))
install.new = sapply(dist.new,function(x) sum(df$install[df$dist==x]))
df = data.frame(dist=dist.new, abnormal=abnormal.new, install=install.new)
df$dist=as.character(df$dist)
# 去掉安徽
df=df[df$dist!="安徽",]
library(devtools)
#install_github("lijian13/RbaiduLBS") #An interface to Baidu LBS API - Jian Li
library(RbaiduLBS)
baidu.ak = 'xLPyzk9xAIvPvvetSpV7BIvZoohSZIsB' # 申请的百度地图access key
df$longitude = NA
df$latitude = NA
for(i in 1:nrow(df)){
geo.info = getGeocoding(address = df$dist[i], ak = baidu.ak)
df$longitude[i] = geo.info$lng
df$latitude[i] = geo.info$lat
}
#检查下位置对不对
plot(df$longitude,df$latitude)
text(df$longitude,df$latitude,labels = df$dist)
distance = matrix(nrow=35,ncol=35)
for(i in 1:35){
for(j in 1:35){
distance[i,j] = sqrt((df$longitude[i]-df$longitude[j])^2 + (df$latitude[i]-df$latitude[j])^2)
}
}
cost = matrix(nrow=35,ncol=35)
for(i in 1:35){
for(j in 1:35){
cost[i,j] = distance[i,j] * (df$abnormal[j]+0.1) #+0.1以避免0产生
}
}
rownames(cost) = 1:35
cost.compute = function(ivec){  # ivec: vector of i_1,i_2,...,i_N
if(length(ivec)==1){return(sum(cost[ivec,]))} # avoid error
mincost = apply(cost[ivec,],2,min)
return(sum(mincost))
}
# 贪心算法：每次都选择所剩区域中成本最小的点来作为新加入的驻扎点，但已加入的驻扎点不变
# 优点：快速
# 缺点：可能不是全局最优解。例如N=1时可能应该选择的是比较中央的驻扎点，但是N=2时显然就不应该选择中央的点，而是分成两边各选一个点来就近负责各自的大区域
greedy = function(N){
selection = c()
for(i in 1:N){
if(length(selection)==0){candidate = (1:35)}else{
candidate = (1:35)[-selection] #候选点
}
cost.all = sapply(candidate, function(x) cost.compute(c(selection,x))) #计算加入这个点以后cost的大小
selection = c(selection, candidate[which.min(cost.all)]) #选使cost最小的点，加入selection
}
selection = sort(selection)
return(list(selection=selection, cities=df$dist[selection],
cost=cost.compute(selection)))
}
greedy(5)
enumerate = function(N){
subset = t(combn(1:35,N))
cost.subset = apply(subset,1,cost.compute)
mincost = which.min(cost.subset)
selection = subset[mincost,]
return(list(selection=selection, cities=df$dist[selection],
cost=cost.subset[mincost]))
}
enumerate(5)
result = enumerate(5)
df
head(df)
df[,c(2,3)]=df[,c(2,3)]/1.4
head(df)
result
selection = result$selection #驻扎点
classn = apply(cost[selection,],2,which.min) #每个城市分类
plot(df$longitude,df$latitude,col=classn+1)
text(df$longitude,df$latitude,labels = df$dist,col=classn+1)
points(df$longitude[selection],df$latitude[selection],pch=19,col=1)
class.selection = selection[classn]
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = sum(df$install[classn==i])
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.monitor,col=1)
N.repair = rep(0,5)
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = round(sum(df$install[classn==i]))
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.monitor,col=1)
N.repair = rep(0,5)
result
selection = result$selection #驻扎点
classn = apply(cost[selection,],2,which.min) #每个城市分类
plot(df$longitude,df$latitude,col=classn+1)
text(df$longitude,df$latitude,labels = df$dist,col=classn+1)
points(df$longitude[selection],df$latitude[selection],pch=19,col=1)
class.selection = selection[classn]
#计算每个驻扎点需要监控的电站数目
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = round(sum(df$install[classn==i]))
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.monitor,col=1)
#计算每个驻扎点需要修理的电站数目
N.repair = rep(0,5)
for(i in 1:5){
N.repair[i] = round(sum(df$abnormal[classn==i]))
}
text(df$longitude[selection]+0.2,df$latitude[selection]-0.1,labels = N.repair,col=1)
N.people = round(N.monitor/4/250+0.5)
names(N.people) = result$cities
N.people
plot(df$longitude,df$latitude,col=classn+1, xlab="经度",ylab="纬度")
text(df$longitude,df$latitude,labels = df$dist,col=classn+1)
points(df$longitude[selection],df$latitude[selection],pch=19,col=1)
class.selection = selection[classn]
#计算每个驻扎点需要监控的电站数目
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = round(sum(df$install[classn==i]))
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.monitor,col=1)
#计算每个驻扎点需要修理的电站数目
N.repair = rep(0,5)
for(i in 1:5){
N.repair[i] = round(sum(df$abnormal[classn==i]))
}
text(df$longitude[selection]+0.2,df$latitude[selection]-0.1,labels = N.repair,col=1)
#人手数目
# 每人每天看4个电站，每年工作250天，每年所有电站看1次
compare = function(x,y){mat = cbind(x,y);apply(mat,1,max)} #用来找到两个vector中较大的
N.people = round(N.monitor/4/250+0.5)
names(N.people) = result$cities
N.people
text(df$longitude[selection]-0.2,df$latitude[selection],labels = N.people,col=1)
# 每人每天看4个，每3天修1个电站，每年工作250天，每年所有电站看2次
# N.people2 = compare(round(N.monitor*2/4/250+0.5),round(N.repair*2*3/250+0.5))
# names(N.people2) = result$cities
# N.people2
plot(df$longitude,df$latitude,col=classn+1, xlab="经度",ylab="纬度")
text(df$longitude,df$latitude,labels = df$dist,col=classn+1)
points(df$longitude[selection],df$latitude[selection],pch=19,col=1)
class.selection = selection[classn]
#计算每个驻扎点需要监控的电站数目
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = round(sum(df$install[classn==i]))
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.monitor,col=1)
#计算每个驻扎点需要修理的电站数目
N.repair = rep(0,5)
for(i in 1:5){
N.repair[i] = round(sum(df$abnormal[classn==i]))
}
text(df$longitude[selection]+0.2,df$latitude[selection]-0.1,labels = N.repair,col=1)
#人手数目
# 每人每天看4个电站，每年工作250天，每年所有电站看1次
compare = function(x,y){mat = cbind(x,y);apply(mat,1,max)} #用来找到两个vector中较大的
N.people = round(N.monitor/4/250+0.5)
names(N.people) = result$cities
N.people
text(df$longitude[selection]-0.1,df$latitude[selection],labels = N.people,col=1)
result
for(i in 1:5){
print(df$dist[nclass==i])
}
for(i in 1:5){
print(df$dist[classn==i])
}
for(i in 1:5){
print(paste(df$dist[classn==i],sep = "，"))
}
df$dist[classn==i],sep = "，"
paste(df$dist[classn==i],sep = "，")
df$dist[classn==i]
class(paste(df$dist[classn==i],sep = "，"))
paste(df$dist[classn==i],sep = "，")
df$dist[classn==i]
class(df$dist[classn==i])
print(paste(df$dist[classn==i][1:sum(classn==i)],sep = "，"))
print(paste(df$dist[classn==i][1:sum(classn==i)],sep = "，"))[1]
paste(c("1","2"))
paste(list("1","2"))
for(i in 1:5){
print(paste(df$dist[classn==i][1:sum(classn==i)],collapse = "，"))
}
N.monitor
N.repair
sum(N.monitor)
sum(N.repair)
N.people
sum(N.people)
# 数据输入
df = read.csv("租赁业务监控安装与并网情况表5.9.csv",encoding = 'UTF-8',stringsAsFactors = F)
df = df[1:42,1:3]
names(df)=c("dist","install","abnormal")
df$ab.rate = df$abnormal / df$install    # abnormal rate
# 合并重复区域
dist.new = unique(df$dist)
abnormal.new = sapply(dist.new,function(x) sum(df$abnormal[df$dist==x]))
install.new = sapply(dist.new,function(x) sum(df$install[df$dist==x]))
df = data.frame(dist=dist.new, abnormal=abnormal.new, install=install.new)
df$dist=as.character(df$dist)
# 去掉安徽
df=df[df$dist!="安徽",]
# 找经纬度
library(devtools)
#install_github("lijian13/RbaiduLBS") #An interface to Baidu LBS API - Jian Li
library(RbaiduLBS)
baidu.ak = 'xLPyzk9xAIvPvvetSpV7BIvZoohSZIsB' # 申请的百度地图access key
df$longitude = NA
df$latitude = NA
for(i in 1:nrow(df)){
geo.info = getGeocoding(address = df$dist[i], ak = baidu.ak)
df$longitude[i] = geo.info$lng
df$latitude[i] = geo.info$lat
}
#检查下位置对不对
plot(df$longitude,df$latitude)
text(df$longitude,df$latitude,labels = df$dist)
result = enumerate(5)
result
selection = result$selection #驻扎点
classn = apply(cost[selection,],2,which.min) #每个城市分类
plot(df$longitude,df$latitude,col=classn+1, xlab="经度",ylab="纬度")
text(df$longitude,df$latitude,labels = df$dist,col=classn+1)
points(df$longitude[selection],df$latitude[selection],pch=19,col=1)
class.selection = selection[classn]
N.monitor = rep(0,5)
for(i in 1:5){
N.monitor[i] = round(sum(df$install[classn==i]))
}
text(df$longitude[selection]+0.2,df$latitude[selection]+0.1,labels = N.monitor,col=1)
N.repair = rep(0,5)
for(i in 1:5){
N.repair[i] = round(sum(df$abnormal[classn==i]))
}
text(df$longitude[selection]+0.2,df$latitude[selection]-0.1,labels = N.repair,col=1)
compare = function(x,y){mat = cbind(x,y);apply(mat,1,max)} #用来找到两个vector中较大的
N.people = round(N.monitor/4/250+0.5)
names(N.people) = result$cities
N.people
text(df$longitude[selection]-0.1,df$latitude[selection],labels = N.people,col=1)
for(i in 1:5){
print(paste(df$dist[classn==i][1:sum(classn==i)],collapse = "，"))
}
N.people
N.monitor
sum(N.monitor)
N.repair
sum(N.repair)
